#!/usr/bin/env python3
"""
TikTok Telegram Bot - نسخة Termux

هذا البوت يسمح بتنزيل محتوى TikTok (فيديوهات، صور، صوتيات) باستخدام Telegram
تم تعديله خصيصاً للعمل على Termux باستخدام مكتبة pyTelegramBotAPI (telebot)

أنشئ بواسطة: @hsooooo0

المتطلبات:
- Python 3.7+
- requests
- pyTelegramBotAPI
- ffmpeg-python

للاستخدام:
1. تثبيت المكتبات المطلوبة: pip install pyTelegramBotAPI requests ffmpeg-python
2. تكوين المتغيرات الخاصة بك (TOKEN, BOT_OWNER_USERNAME, إلخ)
3. تشغيل البوت: python termux_tiktok_bot.py
"""

import os
import re
import uuid
import json
import time
import logging
import shutil
import mimetypes
import subprocess
import requests
from pathlib import Path
from datetime import datetime, timedelta
from collections import defaultdict

try:
    import telebot
    from telebot import types
except ImportError:
    print("مكتبة pyTelegramBotAPI غير مثبتة")
    print("قم بتثبيتها: pip install pyTelegramBotAPI")
    exit(1)

# تكوين السجلات
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# إضافة أنواع الملفات الصوتية والصور
mimetypes.add_type('audio/mp3', '.mp3')
mimetypes.add_type('audio/m4a', '.m4a')
mimetypes.add_type('image/jpeg', '.jpg')
mimetypes.add_type('image/jpeg', '.jpeg')
mimetypes.add_type('image/png', '.png')
mimetypes.add_type('image/webp', '.webp')

# ==========================
# === إعدادات التكوين ===
# ==========================

# ضع توكن البوت الخاص بك هنا، الذي تحصل عليه من BotFather
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "8164109342:AAFU4pdsS9p0udZR23f1MSQ6UuOSNmcREFc")

# معلومات المطور ومعلومات القناة
BOT_OWNER_USERNAME = os.getenv("BOT_OWNER", "hsooooo0")  # اسم المستخدم الخاص بك (بدون @)
BOT_OWNER_ID = int(os.getenv("BOT_OWNER_ID", "5847409161"))  # معرف المطور (رقم)
CHANNEL_USERNAME = os.getenv("CHANNEL", "popou77")    # اسم قناتك (بدون @)
FORCE_SUBSCRIBE = True  # تفعيل الاشتراك الإجباري

# إنشاء كائن البوت
bot = telebot.TeleBot(TOKEN, parse_mode='HTML')

# لوحة المفاتيح الأساسية
def get_main_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    keyboard.add('📥 كيفية الاستخدام', '📌 المطور')
    keyboard.add('📢 قناتنا', '📱 مشاركة البوت')
    return keyboard

# لوحة مفاتيح للوسائط
def get_media_keyboard():
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("🎵 تحويل إلى صوت", callback_data="convert_to_audio"))
    return keyboard

# لوحة مفاتيح التحقق من الاشتراك
def get_verify_keyboard():
    """إنشاء لوحة مفاتيح للتحقق من الاشتراك"""
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("🔄 تحقق من الاشتراك", callback_data="verify_subscription"))
    return keyboard

# الرسائل
WELCOME_MESSAGE = """
👋 <b>أهلاً بك في بوت تحميل TikTok!</b>

🔹 يتيح لك هذا البوت تحميل محتوى TikTok بدون علامة مائية:
 - فيديوهات
 - صور
 - أصوات
 - تحويل الفيديو إلى صوت

🔸 <b>كيفية الاستخدام:</b>
فقط أرسل رابط TikTok وسيقوم البوت بمعالجته وإرساله لك.

💎 <b>المطور:</b> @{bot_owner}
"""

LOADING_MESSAGE = "⏳ *جاري تحميل المحتوى... انتظر قليلاً*"
CONVERTING_MESSAGE = "⏳ *جاري تحويل الفيديو إلى صوت... انتظر قليلاً*"
SUCCESS_MESSAGE = "✅ تم التحميل بنجاح!\n\n👨‍💻 مطور البوت: @{bot_owner}"
AUDIO_SUCCESS_MESSAGE = "✅ تم تحويل الفيديو إلى صوت بنجاح!\n\n👨‍💻 مطور البوت: @{bot_owner}"
ERROR_MESSAGE = "❌ عذراً، حدث خطأ أثناء التحميل. حاول مرة أخرى لاحقاً."
INVALID_URL_MESSAGE = "❌ الرابط غير صالح! تأكد من أنه رابط تيك توك."
NETWORK_ERROR_MESSAGE = "⚠️ خطأ في الاتصال بالإنترنت. حاول مرة أخرى."
FILE_TOO_LARGE_MESSAGE = "⚠️ عذراً، حجم الملف كبير جداً (الحد الأقصى 50 ميجابايت)."
HELP_MESSAGE = """
📥 <b>كيفية استخدام بوت تحميل TikTok:</b>

1️⃣ انسخ رابط الفيديو أو الصورة من تطبيق TikTok
2️⃣ أرسل الرابط إلى البوت
3️⃣ انتظر حتى يتم معالجة المحتوى وتحميله
4️⃣ استمتع بالمحتوى بدون علامة مائية!

🔸 يمكنك أيضًا تحويل الفيديو إلى صوت بالضغط على زر "تحويل إلى صوت" بعد تحميل الفيديو.

🌟 <b>روابط مدعومة:</b>
- https://www.tiktok.com/@username/video/1234567890123456789
- https://vm.tiktok.com/ABCDEF/
- https://vt.tiktok.com/ABCDEF/
"""

# رسائل الاشتراك الإجباري
NOT_SUBSCRIBED_MESSAGE = """
❌ عذراً، يجب عليك الاشتراك في القنوات أولاً!

📢 القنوات المطلوبة:
{channels}

🔄 اشترك في القنوات ثم اضغط على زر التحقق أدناه
"""

# الحد الأقصى لحجم الملف (50 ميجابايت)
MAX_FILE_SIZE = 50 * 1024 * 1024

# API endpoint settings for TikTok downloading services
TIKTOK_API_ENDPOINTS = [
    "https://api.tikmate.app/api/lookup",
    "https://api16-normal-c-useast1a.tiktokv.com/aweme/v1/feed/",
    "https://api.snaptik.app/api/download"
]

# User agent for requests
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"

# RapidAPI TikTok API Settings
RAPIDAPI_URL = "https://tiktok-api23.p.rapidapi.com/api/collection/posts"
RAPIDAPI_KEY = os.getenv("RAPIDAPI_KEY", "0aedfc77c2msh76f907ee95148bcp17815ejsnfc226a83532d")
RAPIDAPI_HOST = "tiktok-api23.p.rapidapi.com"

# مسار لحفظ الملفات المؤقتة
TEMP_DIR = Path("temp_files")
TEMP_DIR.mkdir(exist_ok=True)

# قاموس لتخزين آخر فيديو تم تحميله لكل مستخدم
user_last_video = {}

# قاموس لتخزين حالة المستخدمين
user_states = {}
banned_users = set()
download_stats = defaultdict(int)

# ==========================
# === وظائف المساعدة ===
# ==========================

def extract_tiktok_id(url):
    """Extract TikTok video ID from URL"""
    try:
        # Handle TikTok URL patterns
        if '/video/' in url:
            video_id = url.split('/video/')[1].split('?')[0]
            return video_id
        
        # Handle shortened URL format
        if 'vm.tiktok.com' in url or 'vt.tiktok.com' in url:
            response = requests.head(url, allow_redirects=True)
            final_url = response.url
            if '/video/' in final_url:
                video_id = final_url.split('/video/')[1].split('?')[0]
                return video_id
        
        # Extract using regex pattern for various formats
        pattern = r'(\d{18,19})'
        match = re.search(pattern, url)
        if match:
            return match.group(1)
        
        return None
    except Exception as e:
        logger.error(f"Error extracting TikTok ID: {e}")
        return None

def download_using_tikmate(url, output_path):
    """Download TikTok video using TikMate API"""
    try:
        headers = {
            'User-Agent': USER_AGENT,
            'Referer': 'https://tikmate.app/',
            'Origin': 'https://tikmate.app'
        }
        
        data = {
            'url': url
        }
        
        # First request to get the download token
        response = requests.post(
            TIKTOK_API_ENDPOINTS[0], 
            headers=headers, 
            data=data
        )
        
        if response.status_code != 200:
            logger.error(f"TikMate API error: {response.status_code}")
            return False
        
        try:
            result = response.json()
            if 'token' not in result:
                logger.error("No token found in response")
                return False
            
            token = result['token']
            
            # Second request to download the actual video
            download_url = f"https://tikmate.app/download/{token}/hd.mp4"
            
            video_response = requests.get(
                download_url, 
                headers=headers, 
                stream=True
            )
            
            if video_response.status_code != 200:
                logger.error(f"Video download error: {video_response.status_code}")
                return False
            
            # Save the video file
            with open(output_path, 'wb') as f:
                for chunk in video_response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
            
            return os.path.exists(output_path) and os.path.getsize(output_path) > 0
            
        except json.JSONDecodeError:
            logger.error("Failed to parse JSON response")
            return False
            
    except Exception as e:
        logger.error(f"TikMate download error: {e}")
        return False

def download_using_snaptik(url, output_path):
    """Download TikTok video using SnapTik API"""
    try:
        headers = {
            'User-Agent': USER_AGENT,
            'Referer': 'https://snaptik.app/',
            'Origin': 'https://snaptik.app'
        }
        
        data = {
            'url': url,
            'action': 'post'
        }
        
        # First request to get the download link
        response = requests.post(
            TIKTOK_API_ENDPOINTS[2],
            headers=headers,
            data=data
        )
        
        if response.status_code != 200:
            logger.error(f"SnapTik API error: {response.status_code}")
            return False
        
        try:
            result = response.json()
            if not result.get('status') or 'data' not in result:
                logger.error("No valid data found in response")
                return False
            
            download_data = result['data']
            # Find HD download link
            download_url = None
            for item in download_data:
                if item.get('type') == 'HD':
                    download_url = item.get('url')
                    break
            
            if not download_url:
                # Fallback to first available link
                for item in download_data:
                    if 'url' in item:
                        download_url = item.get('url')
                        break
            
            if not download_url:
                logger.error("No download URL found")
                return False
            
            # Download the video
            video_response = requests.get(
                download_url,
                headers=headers,
                stream=True
            )
            
            if video_response.status_code != 200:
                logger.error(f"Video download error: {video_response.status_code}")
                return False
            
            # Save the video file
            with open(output_path, 'wb') as f:
                for chunk in video_response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
            
            return os.path.exists(output_path) and os.path.getsize(output_path) > 0
            
        except (json.JSONDecodeError, KeyError):
            logger.error("Failed to parse JSON response")
            return False
            
    except Exception as e:
        logger.error(f"SnapTik download error: {e}")
        return False
        
def get_media_type_from_content(response):
    """تحديد نوع الوسائط من الاستجابة"""
    try:
        content_type = response.headers.get('Content-Type', '').lower()
        
        if 'image' in content_type:
            return 'image'
        elif 'audio' in content_type:
            return 'audio'
        elif 'video' in content_type:
            return 'video'
        else:
            # تحديد النوع من خلال امتداد الملف من عنوان URL
            file_ext = os.path.splitext(response.url)[-1].lower()
            if file_ext in ['.jpg', '.jpeg', '.png', '.webp', '.gif']:
                return 'image'
            elif file_ext in ['.mp3', '.wav', '.m4a', '.ogg']:
                return 'audio'
            else:
                return 'video'  # افتراضيًا، نعتبره فيديو
    except:
        return 'video'  # في حالة حدوث خطأ، نعتبره فيديو افتراضيًا

def get_appropriate_file_extension(media_type, url=''):
    """الحصول على امتداد الملف المناسب بناءً على نوع الوسائط"""
    if media_type == 'image':
        # استخراج الامتداد من URL إذا كان متاحًا
        if url and '.' in url:
            ext = os.path.splitext(url)[-1].lower()
            if ext in ['.jpg', '.jpeg', '.png', '.webp', '.gif']:
                return ext
        return '.jpg'  # امتداد افتراضي للصور
    elif media_type == 'audio':
        # استخراج الامتداد من URL إذا كان متاحًا
        if url and '.' in url:
            ext = os.path.splitext(url)[-1].lower()
            if ext in ['.mp3', '.m4a', '.wav', '.ogg']:
                return ext
        return '.mp3'  # امتداد افتراضي للصوتيات
    else:  # video
        return '.mp4'  # امتداد افتراضي للفيديوهات

def download_tiktok_content(url):
    """تنزيل محتوى تيك توك باستخدام الطرق المختلفة"""
    try:
        # إنشاء اسم ملف فريد بناءً على UUID
        file_id = str(uuid.uuid4())
        video_path = TEMP_DIR / f"{file_id}.mp4"
        
        # محاولة التنزيل باستخدام TikMate
        tikmate_success = download_using_tikmate(url, video_path)
        if tikmate_success:
            logger.info("Download successful using TikMate API")
            return video_path
        
        # محاولة التنزيل باستخدام SnapTik
        snaptik_success = download_using_snaptik(url, video_path)
        if snaptik_success:
            logger.info("Download successful using SnapTik API")
            return video_path
        
        # استخدام RapidAPI كخيار أخير
        try:
            video_id = extract_tiktok_id(url)
            if not video_id:
                logger.error("Failed to extract video ID")
                return None
                
            headers = {
                "X-RapidAPI-Key": RAPIDAPI_KEY,
                "X-RapidAPI-Host": RAPIDAPI_HOST
            }
            
            query = {
                "tiktok_urls": [url]
            }
            
            response = requests.post(RAPIDAPI_URL, json=query, headers=headers)
            
            if response.status_code != 200:
                logger.error(f"RapidAPI error: {response.status_code}")
                return None
                
            data = response.json()
            posts = data.get('collection', {}).get('posts', [])
            
            if not posts:
                logger.error("No posts found in response")
                return None
                
            post = posts[0]
            download_url = None
            output_path = None
            
            # Get video or image URL
            if 'images' in post and post['images']:
                # This is an image post
                download_url = post['images'][0]
                media_type = 'image'
                file_ext = get_appropriate_file_extension(media_type, download_url)
                output_path = TEMP_DIR / f"{file_id}{file_ext}"
            elif 'video' in post and post['video'] and 'download_url' in post['video']:
                # This is a video post
                download_url = post['video']['download_url']
                media_type = 'video'
                file_ext = get_appropriate_file_extension(media_type, download_url)
                output_path = TEMP_DIR / f"{file_id}{file_ext}"
            
            if not download_url or not output_path:
                logger.error("No download URL found in the response")
                return None
                
            # Download the content
            content_response = requests.get(download_url, stream=True)
            
            if content_response.status_code != 200:
                logger.error(f"Content download error: {content_response.status_code}")
                return None
                
            # Save the file
            with open(output_path, 'wb') as f:
                for chunk in content_response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
                        
            if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                logger.info(f"Download successful using RapidAPI")
                return output_path
                
        except Exception as e:
            logger.error(f"RapidAPI download error: {e}")
            
        logger.error("All download methods failed")
        return None
        
    except Exception as e:
        logger.error(f"Download error: {e}")
        return None

def convert_video_to_audio(video_path):
    """تحويل الفيديو إلى ملف صوتي باستخدام ffmpeg"""
    try:
        # إنشاء اسم ملف للصوت
        audio_path = str(video_path).replace('.mp4', '.mp3')
        
        # استخدام subprocess لتشغيل ffmpeg
        subprocess.run([
            'ffmpeg', '-i', str(video_path), 
            '-q:a', '0', '-map', 'a', str(audio_path), 
            '-y'  # الكتابة فوق الملف إذا كان موجوداً
        ], check=True, capture_output=True)
        
        # التحقق من أن الملف تم إنشاؤه
        if os.path.exists(audio_path) and os.path.getsize(audio_path) > 0:
            return audio_path
        return None
    except Exception as e:
        logger.error(f"Error converting video to audio: {e}")
        return None

def clean_old_files():
    """حذف الملفات المؤقتة القديمة (أكثر من ساعة)"""
    try:
        now = datetime.now()
        threshold = now - timedelta(hours=1)
        count = 0
        
        for file_path in TEMP_DIR.glob("*"):
            try:
                # الحصول على وقت التعديل (unix timestamp)
                mtime = file_path.stat().st_mtime
                mtime_datetime = datetime.fromtimestamp(mtime)
                
                # حذف الملفات القديمة
                if mtime_datetime < threshold:
                    os.remove(file_path)
                    count += 1
            except Exception as e:
                logger.error(f"Error cleaning file {file_path}: {e}")
                
        logger.info(f"Cleaned {count} old files from temp directory")
    except Exception as e:
        logger.error(f"Error in clean_old_files: {e}")

def is_channel_member(user_id, channel_username):
    """التحقق مما إذا كان المستخدم عضوًا في القناة"""
    try:
        member = bot.get_chat_member(f"@{channel_username}", user_id)
        # التحقق من حالة العضوية (الحالات المقبولة: عضو، مشرف، منشئ)
        if member.status in ['member', 'administrator', 'creator']:
            return True
        return False
    except Exception as e:
        logger.error(f"Error checking channel membership: {e}")
        # في حالة حدوث خطأ، نفترض أنه غير مشترك
        return False

def check_subscription(user_id):
    """التحقق من اشتراك المستخدم في القنوات المطلوبة"""
    # إذا كان الاشتراك الإجباري غير مفعل، نعتبره مشتركًا
    if not FORCE_SUBSCRIBE:
        return True
        
    # إذا كان المستخدم هو مطور البوت، لا نحتاج للتحقق
    if user_id == BOT_OWNER_ID:
        return True
        
    # التحقق من اشتراك المستخدم في القناة
    return is_channel_member(user_id, CHANNEL_USERNAME)

# ==========================
# === معالجات الأحداث ===
# ==========================

@bot.message_handler(commands=['start'])
def start(message):
    """عند بدء المحادثة، ترسل رسالة ترحيب"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # التحقق مما إذا كان المستخدم محظورًا
    if user_id in banned_users:
        bot.send_message(chat_id, "⛔ أنت محظور من استخدام هذا البوت.")
        return
    
    # التحقق من الاشتراك في القناة
    if not check_subscription(user_id):
        channels_text = f"@{CHANNEL_USERNAME}"
        msg = NOT_SUBSCRIBED_MESSAGE.format(channels=channels_text)
        bot.send_message(chat_id, msg, reply_markup=get_verify_keyboard())
        return
    
    # إرسال رسالة الترحيب
    welcome_msg = WELCOME_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
    bot.send_message(chat_id, welcome_msg, reply_markup=get_main_keyboard())

@bot.message_handler(commands=['help'])
def help_command(message):
    """إرسال رسالة المساعدة عند استخدام الأمر /help"""
    chat_id = message.chat.id
    bot.send_message(chat_id, HELP_MESSAGE, reply_markup=get_main_keyboard())

@bot.message_handler(commands=['about'])
def about_developer(message):
    """معلومات عن مطور البوت"""
    chat_id = message.chat.id
    about_text = f"""
📱 <b>معلومات عن المطور:</b>

👤 <b>المطور:</b> @{BOT_OWNER_USERNAME}

🔹 <b>للتواصل أو الاستفسار:</b>
يمكنك التواصل مع المطور مباشرة عبر حسابه على تيليجرام
    """
    bot.send_message(chat_id, about_text)

@bot.callback_query_handler(func=lambda call: call.data == "verify_subscription")
def verify_subscription(call):
    """التحقق من اشتراك المستخدم"""
    chat_id = call.message.chat.id
    user_id = call.from_user.id
    
    # التحقق من الاشتراك
    if check_subscription(user_id):
        # إذا كان مشتركًا، أرسل رسالة الترحيب
        bot.answer_callback_query(call.id, "✅ تم التحقق من اشتراكك بنجاح!")
        bot.delete_message(chat_id, call.message.message_id)
        welcome_msg = WELCOME_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
        bot.send_message(chat_id, welcome_msg, reply_markup=get_main_keyboard())
    else:
        # إذا لم يكن مشتركًا بعد
        bot.answer_callback_query(call.id, "❌ يجب عليك الاشتراك في القناة أولاً!", show_alert=True)

@bot.message_handler(func=lambda message: bool(re.search(r'(vm\.tiktok\.com|vt\.tiktok\.com|tiktok\.com)', message.text)))
def handle_urls(message):
    """معالجة روابط TikTok ومحاولة تنزيلها"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    tiktok_url = message.text.strip()

    # التحقق مما إذا كان المستخدم محظورًا
    if user_id in banned_users:
        bot.send_message(chat_id, "⛔ أنت محظور من استخدام هذا البوت.")
        return
    
    # التحقق من الاشتراك
    if not check_subscription(user_id):
        channels_text = f"@{CHANNEL_USERNAME}"
        msg = NOT_SUBSCRIBED_MESSAGE.format(channels=channels_text)
        bot.send_message(chat_id, msg, reply_markup=get_verify_keyboard())
        return
    
    # إرسال رسالة التحميل
    loading_msg = bot.send_message(chat_id, LOADING_MESSAGE, parse_mode='Markdown')
    
    try:
        # تنزيل المحتوى
        downloaded_file = download_tiktok_content(tiktok_url)
        
        if not downloaded_file:
            # فشل التنزيل
            bot.edit_message_text(ERROR_MESSAGE, chat_id, loading_msg.message_id, parse_mode='Markdown')
            return
            
        # التحقق من حجم الملف
        file_size = os.path.getsize(downloaded_file)
        if file_size > MAX_FILE_SIZE:
            bot.edit_message_text(FILE_TOO_LARGE_MESSAGE, chat_id, loading_msg.message_id, parse_mode='Markdown')
            return
            
        # تحديد نوع الملف وإرساله
        file_ext = os.path.splitext(downloaded_file)[1].lower()
        
        success_msg = SUCCESS_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
        
        if file_ext in ['.jpg', '.jpeg', '.png', '.webp', '.gif']:
            # إرسال الصورة
            with open(downloaded_file, 'rb') as photo:
                bot.send_photo(chat_id, photo, caption=success_msg)
        elif file_ext in ['.mp3', '.m4a', '.wav', '.ogg']:
            # إرسال الصوت
            with open(downloaded_file, 'rb') as audio:
                bot.send_audio(chat_id, audio, caption=success_msg)
        else:
            # إرسال الفيديو
            with open(downloaded_file, 'rb') as video:
                sent_msg = bot.send_video(chat_id, video, caption=success_msg, reply_markup=get_media_keyboard())
                # تخزين معلومات الفيديو للمستخدم (للتحويل إلى صوت لاحقًا)
                user_last_video[user_id] = str(downloaded_file)
        
        # تحديث الإحصائيات
        download_stats[user_id] += 1
        
        # حذف رسالة التحميل
        bot.delete_message(chat_id, loading_msg.message_id)
        
    except Exception as e:
        logger.error(f"Error handling TikTok URL: {e}")
        bot.edit_message_text(ERROR_MESSAGE, chat_id, loading_msg.message_id, parse_mode='Markdown')

@bot.callback_query_handler(func=lambda call: call.data == "convert_to_audio")
def convert_to_audio_callback(call):
    """تحويل الفيديو إلى ملف صوتي"""
    chat_id = call.message.chat.id
    user_id = call.from_user.id
    
    # التحقق من وجود فيديو مخزن للمستخدم
    if user_id not in user_last_video:
        bot.answer_callback_query(call.id, "⚠️ لم يتم العثور على فيديو لتحويله!", show_alert=True)
        return
        
    # الحصول على مسار الفيديو
    video_path = user_last_video[user_id]
    if not os.path.exists(video_path):
        bot.answer_callback_query(call.id, "⚠️ الفيديو غير متوفر الآن. حاول تنزيله مرة أخرى!", show_alert=True)
        return
        
    # إرسال رسالة التحويل
    bot.answer_callback_query(call.id, "🎵 جاري تحويل الفيديو إلى صوت...")
    converting_msg = bot.send_message(chat_id, CONVERTING_MESSAGE, parse_mode='Markdown')
    
    try:
        # تحويل الفيديو إلى صوت
        audio_path = convert_video_to_audio(video_path)
        
        if not audio_path:
            # فشل التحويل
            bot.edit_message_text(ERROR_MESSAGE, chat_id, converting_msg.message_id, parse_mode='Markdown')
            return
            
        # إرسال الملف الصوتي
        with open(audio_path, 'rb') as audio:
            success_msg = AUDIO_SUCCESS_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
            bot.send_audio(chat_id, audio, caption=success_msg)
            
        # حذف رسالة التحويل
        bot.delete_message(chat_id, converting_msg.message_id)
        
    except Exception as e:
        logger.error(f"Error converting to audio: {e}")
        bot.edit_message_text(ERROR_MESSAGE, chat_id, converting_msg.message_id, parse_mode='Markdown')

@bot.message_handler(commands=['stats'])
def show_bot_stats(message):
    """عرض إحصائيات البوت للمطور"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # فقط المطور يمكنه الوصول للإحصائيات
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "⛔ هذا الأمر متاح فقط للمطور!")
        return
    
    # جمع الإحصائيات
    total_users = len(download_stats)
    total_downloads = sum(download_stats.values())
    
    # الحصول على أكثر المستخدمين نشاطًا
    top_users = sorted(download_stats.items(), key=lambda x: x[1], reverse=True)[:5]
    top_users_text = ""
    
    for i, (user_id, count) in enumerate(top_users, 1):
        try:
            user = bot.get_chat(user_id)
            username = f"@{user.username}" if user.username else f"User {user_id}"
            top_users_text += f"{i}. {username}: {count} عملية تنزيل\n"
        except:
            top_users_text += f"{i}. User {user_id}: {count} عملية تنزيل\n"
    
    # إعداد رسالة الإحصائيات
    stats_message = f"""
📊 <b>إحصائيات البوت:</b>

👥 <b>إجمالي المستخدمين:</b> {total_users}
📥 <b>إجمالي التنزيلات:</b> {total_downloads}
🔒 <b>مستخدمين محظورين:</b> {len(banned_users)}

🔝 <b>أكثر المستخدمين نشاطًا:</b>
{top_users_text}
    """
    
    bot.send_message(chat_id, stats_message)

@bot.message_handler(commands=['users'])
def show_users_count(message):
    """عرض عدد مستخدمي البوت للمطور"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # فقط المطور يمكنه الوصول للإحصائيات
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "⛔ هذا الأمر متاح فقط للمطور!")
        return
    
    # جمع الإحصائيات
    total_users = len(download_stats)
    total_downloads = sum(download_stats.values())
    
    # إعداد رسالة الإحصائيات
    stats_message = f"""
👥 <b>إحصائيات المستخدمين:</b>

📊 <b>إجمالي المستخدمين:</b> {total_users}
📥 <b>إجمالي التنزيلات:</b> {total_downloads}
    """
    
    bot.send_message(chat_id, stats_message)

@bot.message_handler(commands=['ban'])
def ban_user_command(message):
    """بدء عملية حظر مستخدم"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # فقط المطور يمكنه حظر المستخدمين
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "⛔ هذا الأمر متاح فقط للمطور!")
        return
    
    # الطلب من المطور إدخال معرف المستخدم
    bot.send_message(chat_id, "🛑 أدخل معرف المستخدم الذي تريد حظره (رقم):")
    # تعيين حالة المطور لانتظار معرف المستخدم
    user_states[user_id] = "waiting_for_user_id_ban"

@bot.message_handler(commands=['unban'])
def unban_user_command(message):
    """بدء عملية إلغاء حظر مستخدم"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # فقط المطور يمكنه إلغاء حظر المستخدمين
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "⛔ هذا الأمر متاح فقط للمطور!")
        return
    
    # إذا لم يكن هناك مستخدمين محظورين
    if not banned_users:
        bot.send_message(chat_id, "ℹ️ لا يوجد مستخدمين محظورين حاليًا.")
        return
    
    # إظهار قائمة المستخدمين المحظورين
    banned_list = "\n".join([f"- {user_id}" for user_id in banned_users])
    bot.send_message(chat_id, f"📋 قائمة المستخدمين المحظورين:\n{banned_list}")
    
    # الطلب من المطور إدخال معرف المستخدم
    bot.send_message(chat_id, "🔓 أدخل معرف المستخدم الذي تريد إلغاء حظره (رقم):")
    # تعيين حالة المطور لانتظار معرف المستخدم
    user_states[user_id] = "waiting_for_user_id_unban"

@bot.message_handler(func=lambda message: message.text == '📥 كيفية الاستخدام')
def handle_help(message):
    """إرسال رسالة المساعدة"""
    chat_id = message.chat.id
    bot.send_message(chat_id, HELP_MESSAGE)

@bot.message_handler(func=lambda message: message.text == '📌 المطور')
def handle_about_developer(message):
    """إرسال معلومات عن المطور"""
    chat_id = message.chat.id
    about_developer(message)

@bot.message_handler(func=lambda message: message.text == '📢 قناتنا')
def handle_our_channel(message):
    """إرسال معلومات عن قناة البوت"""
    chat_id = message.chat.id
    channel_text = f"""
📢 <b>قناة البوت الرسمية:</b>

تابع قناتنا للحصول على:
- آخر التحديثات
- أخبار البوت
- ميزات جديدة قادمة
- ودعم البوت!

👉 @{CHANNEL_USERNAME}
    """
    # إنشاء زر للقناة
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("🌟 زيارة القناة", url=f"https://t.me/{CHANNEL_USERNAME}"))
    
    bot.send_message(chat_id, channel_text, reply_markup=keyboard)

@bot.message_handler(func=lambda message: message.text == '📱 مشاركة البوت')
def handle_share_bot(message):
    """مشاركة البوت مع الآخرين"""
    chat_id = message.chat.id
    
    share_text = f"""
📱 <b>شارك البوت مع أصدقائك!</b>

استخدم الرابط أدناه لمشاركة بوت تنزيل TikTok مع أصدقائك:

https://t.me/{bot.get_me().username}

شكراً لدعمك! 🙏
    """
    bot.send_message(chat_id, share_text)

@bot.message_handler(func=lambda message: message.from_user.id in user_states)
def handle_admin_action(message):
    """معالجة أوامر المطور المعلقة"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # تحقق من أن المرسل هو المطور
    if user_id != BOT_OWNER_ID:
        return
    
    # الحصول على حالة المطور الحالية
    state = user_states.get(user_id)
    
    if state == "waiting_for_user_id_ban":
        try:
            # محاولة تحويل المعرف إلى رقم
            target_user_id = int(message.text.strip())
            # إضافة المستخدم إلى قائمة المحظورين
            banned_users.add(target_user_id)
            bot.send_message(chat_id, f"✅ تم حظر المستخدم بمعرف: {target_user_id}")
        except ValueError:
            bot.send_message(chat_id, "❌ معرف غير صالح! الرجاء إدخال رقم صحيح.")
        # إزالة حالة الانتظار
        user_states.pop(user_id, None)
    
    elif state == "waiting_for_user_id_unban":
        try:
            # محاولة تحويل المعرف إلى رقم
            target_user_id = int(message.text.strip())
            # إزالة المستخدم من قائمة المحظورين
            if target_user_id in banned_users:
                banned_users.remove(target_user_id)
                bot.send_message(chat_id, f"✅ تم إلغاء حظر المستخدم بمعرف: {target_user_id}")
            else:
                bot.send_message(chat_id, f"ℹ️ المستخدم بمعرف {target_user_id} غير محظور!")
        except ValueError:
            bot.send_message(chat_id, "❌ معرف غير صالح! الرجاء إدخال رقم صحيح.")
        # إزالة حالة الانتظار
        user_states.pop(user_id, None)

@bot.message_handler(func=lambda message: True)
def handle_text(message):
    """معالجة الرسائل النصية"""
    chat_id = message.chat.id
    text = message.text.strip()
    
    # التحقق من وجود روابط TikTok في النص
    if re.search(r'(vm\.tiktok\.com|vt\.tiktok\.com|tiktok\.com)', text):
        # إذا وجد رابط، نقوم بمعالجته
        handle_urls(message)
    else:
        # إذا لم يكن رابط TikTok صالح
        bot.send_message(
            chat_id, 
            "🔹 أرسل رابط فيديو TikTok لتحميله.\n\n🔸 يمكنك الضغط على '📥 كيفية الاستخدام' لمعرفة المزيد."
        )

# ==========================
# === الدالة الرئيسية ===
# ==========================

def main():
    """الدالة الرئيسية لتشغيل البوت"""
    print("🚀 بدء تشغيل البوت TikTok Telegram Bot...")
    print("البوت يقبل الروابط لتحميل محتوى TikTok")
    
    # تنظيف الملفات القديمة عند بدء التشغيل
    clean_old_files()
    
    # تنظيف الملفات القديمة كل ساعة
    import threading
    import time
    
    def clean_task():
        while True:
            time.sleep(3600)  # انتظر ساعة
            clean_old_files()
    
    # بدء مهمة التنظيف في خلفية
    cleaning_thread = threading.Thread(target=clean_task)
    cleaning_thread.daemon = True
    cleaning_thread.start()
    
    # بدء تشغيل البوت
    try:
        bot.polling(none_stop=True, interval=0)
    except Exception as e:
        logger.error(f"Polling error: {e}")
        
if __name__ == "__main__":
    main()