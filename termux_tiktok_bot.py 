#!/usr/bin/env python3
"""
TikTok Telegram Bot - Ù†Ø³Ø®Ø© Termux

Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙŠØ³Ù…Ø­ Ø¨ØªÙ†Ø²ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ TikTok (ÙÙŠØ¯ÙŠÙˆÙ‡Ø§ØªØŒ ØµÙˆØ±ØŒ ØµÙˆØªÙŠØ§Øª) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Telegram
ØªÙ… ØªØ¹Ø¯ÙŠÙ„Ù‡ Ø®ØµÙŠØµØ§Ù‹ Ù„Ù„Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Termux Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙƒØªØ¨Ø© pyTelegramBotAPI (telebot)

Ø£Ù†Ø´Ø¦ Ø¨ÙˆØ§Ø³Ø·Ø©: @hsooooo0

Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª:
- Python 3.7+
- requests
- pyTelegramBotAPI
- ffmpeg-python

Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
1. ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©: pip install pyTelegramBotAPI requests ffmpeg-python
2. ØªÙƒÙˆÙŠÙ† Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ (TOKEN, BOT_OWNER_USERNAME, Ø¥Ù„Ø®)
3. ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: python termux_tiktok_bot.py
"""

import os
import re
import uuid
import json
import time
import logging
import shutil
import mimetypes
import subprocess
import requests
from pathlib import Path
from datetime import datetime, timedelta
from collections import defaultdict

try:
    import telebot
    from telebot import types
except ImportError:
    print("Ù…ÙƒØªØ¨Ø© pyTelegramBotAPI ØºÙŠØ± Ù…Ø«Ø¨ØªØ©")
    print("Ù‚Ù… Ø¨ØªØ«Ø¨ÙŠØªÙ‡Ø§: pip install pyTelegramBotAPI")
    exit(1)

# ØªÙƒÙˆÙŠÙ† Ø§Ù„Ø³Ø¬Ù„Ø§Øª
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Ø¥Ø¶Ø§ÙØ© Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØµÙˆØªÙŠØ© ÙˆØ§Ù„ØµÙˆØ±
mimetypes.add_type('audio/mp3', '.mp3')
mimetypes.add_type('audio/m4a', '.m4a')
mimetypes.add_type('image/jpeg', '.jpg')
mimetypes.add_type('image/jpeg', '.jpeg')
mimetypes.add_type('image/png', '.png')
mimetypes.add_type('image/webp', '.webp')

# ==========================
# === Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ† ===
# ==========================

# Ø¶Ø¹ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ù†Ø§ØŒ Ø§Ù„Ø°ÙŠ ØªØ­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ù…Ù† BotFather
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "8164109342:AAFU4pdsS9p0udZR23f1MSQ6UuOSNmcREFc")

# Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø·ÙˆØ± ÙˆÙ…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ù†Ø§Ø©
BOT_OWNER_USERNAME = os.getenv("BOT_OWNER", "hsooooo0")  # Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ (Ø¨Ø¯ÙˆÙ† @)
BOT_OWNER_ID = int(os.getenv("BOT_OWNER_ID", "5847409161"))  # Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø·ÙˆØ± (Ø±Ù‚Ù…)
CHANNEL_USERNAME = os.getenv("CHANNEL", "popou77")    # Ø§Ø³Ù… Ù‚Ù†Ø§ØªÙƒ (Ø¨Ø¯ÙˆÙ† @)
FORCE_SUBSCRIBE = True  # ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ

# Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ø§Ù„Ø¨ÙˆØª
bot = telebot.TeleBot(TOKEN, parse_mode='HTML')

# Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
def get_main_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    keyboard.add('ğŸ“¥ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…', 'ğŸ“Œ Ø§Ù„Ù…Ø·ÙˆØ±')
    keyboard.add('ğŸ“¢ Ù‚Ù†Ø§ØªÙ†Ø§', 'ğŸ“± Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø¨ÙˆØª')
    return keyboard

# Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ù„Ù„ÙˆØ³Ø§Ø¦Ø·
def get_media_keyboard():
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("ğŸµ ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ØµÙˆØª", callback_data="convert_to_audio"))
    return keyboard

# Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
def get_verify_keyboard():
    """Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ"""
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("ğŸ”„ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", callback_data="verify_subscription"))
    return keyboard

# Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
WELCOME_MESSAGE = """
ğŸ‘‹ <b>Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª ØªØ­Ù…ÙŠÙ„ TikTok!</b>

ğŸ”¹ ÙŠØªÙŠØ­ Ù„Ùƒ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ØªØ­Ù…ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ TikTok Ø¨Ø¯ÙˆÙ† Ø¹Ù„Ø§Ù…Ø© Ù…Ø§Ø¦ÙŠØ©:
 - ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª
 - ØµÙˆØ±
 - Ø£ØµÙˆØ§Øª
 - ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ ØµÙˆØª

ğŸ”¸ <b>ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:</b>
ÙÙ‚Ø· Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· TikTok ÙˆØ³ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨ÙˆØª Ø¨Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡ ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡ Ù„Ùƒ.

ğŸ’ <b>Ø§Ù„Ù…Ø·ÙˆØ±:</b> @{bot_owner}
"""

LOADING_MESSAGE = "â³ *Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰... Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹*"
CONVERTING_MESSAGE = "â³ *Ø¬Ø§Ø±ÙŠ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ ØµÙˆØª... Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹*"
SUCCESS_MESSAGE = "âœ… ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!\n\nğŸ‘¨â€ğŸ’» Ù…Ø·ÙˆØ± Ø§Ù„Ø¨ÙˆØª: @{bot_owner}"
AUDIO_SUCCESS_MESSAGE = "âœ… ØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ ØµÙˆØª Ø¨Ù†Ø¬Ø§Ø­!\n\nğŸ‘¨â€ğŸ’» Ù…Ø·ÙˆØ± Ø§Ù„Ø¨ÙˆØª: @{bot_owner}"
ERROR_MESSAGE = "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹."
INVALID_URL_MESSAGE = "âŒ Ø§Ù„Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ§Ù„Ø­! ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡ Ø±Ø§Ø¨Ø· ØªÙŠÙƒ ØªÙˆÙƒ."
NETWORK_ERROR_MESSAGE = "âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
FILE_TOO_LARGE_MESSAGE = "âš ï¸ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 50 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)."
HELP_MESSAGE = """
ğŸ“¥ <b>ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙˆØª ØªØ­Ù…ÙŠÙ„ TikTok:</b>

1ï¸âƒ£ Ø§Ù†Ø³Ø® Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø£Ùˆ Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† ØªØ·Ø¨ÙŠÙ‚ TikTok
2ï¸âƒ£ Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø§Ø¨Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª
3ï¸âƒ£ Ø§Ù†ØªØ¸Ø± Ø­ØªÙ‰ ÙŠØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙˆØªØ­Ù…ÙŠÙ„Ù‡
4ï¸âƒ£ Ø§Ø³ØªÙ…ØªØ¹ Ø¨Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¨Ø¯ÙˆÙ† Ø¹Ù„Ø§Ù…Ø© Ù…Ø§Ø¦ÙŠØ©!

ğŸ”¸ ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ù‹Ø§ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ ØµÙˆØª Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± "ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ØµÙˆØª" Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.

ğŸŒŸ <b>Ø±ÙˆØ§Ø¨Ø· Ù…Ø¯Ø¹ÙˆÙ…Ø©:</b>
- https://www.tiktok.com/@username/video/1234567890123456789
- https://vm.tiktok.com/ABCDEF/
- https://vt.tiktok.com/ABCDEF/
"""

# Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
NOT_SUBSCRIBED_MESSAGE = """
âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø£ÙˆÙ„Ø§Ù‹!

ğŸ“¢ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:
{channels}

ğŸ”„ Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„ØªØ­Ù‚Ù‚ Ø£Ø¯Ù†Ø§Ù‡
"""

# Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù (50 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)
MAX_FILE_SIZE = 50 * 1024 * 1024

# API endpoint settings for TikTok downloading services
TIKTOK_API_ENDPOINTS = [
    "https://api.tikmate.app/api/lookup",
    "https://api16-normal-c-useast1a.tiktokv.com/aweme/v1/feed/",
    "https://api.snaptik.app/api/download"
]

# User agent for requests
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"

# RapidAPI TikTok API Settings
RAPIDAPI_URL = "https://tiktok-api23.p.rapidapi.com/api/collection/posts"
RAPIDAPI_KEY = os.getenv("RAPIDAPI_KEY", "0aedfc77c2msh76f907ee95148bcp17815ejsnfc226a83532d")
RAPIDAPI_HOST = "tiktok-api23.p.rapidapi.com"

# Ù…Ø³Ø§Ø± Ù„Ø­ÙØ¸ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©
TEMP_DIR = Path("temp_files")
TEMP_DIR.mkdir(exist_ok=True)

# Ù‚Ø§Ù…ÙˆØ³ Ù„ØªØ®Ø²ÙŠÙ† Ø¢Ø®Ø± ÙÙŠØ¯ÙŠÙˆ ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡ Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…
user_last_video = {}

# Ù‚Ø§Ù…ÙˆØ³ Ù„ØªØ®Ø²ÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
user_states = {}
banned_users = set()
download_stats = defaultdict(int)

# ==========================
# === ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ===
# ==========================

def extract_tiktok_id(url):
    """Extract TikTok video ID from URL"""
    try:
        # Handle TikTok URL patterns
        if '/video/' in url:
            video_id = url.split('/video/')[1].split('?')[0]
            return video_id
        
        # Handle shortened URL format
        if 'vm.tiktok.com' in url or 'vt.tiktok.com' in url:
            response = requests.head(url, allow_redirects=True)
            final_url = response.url
            if '/video/' in final_url:
                video_id = final_url.split('/video/')[1].split('?')[0]
                return video_id
        
        # Extract using regex pattern for various formats
        pattern = r'(\d{18,19})'
        match = re.search(pattern, url)
        if match:
            return match.group(1)
        
        return None
    except Exception as e:
        logger.error(f"Error extracting TikTok ID: {e}")
        return None

def download_using_tikmate(url, output_path):
    """Download TikTok video using TikMate API"""
    try:
        headers = {
            'User-Agent': USER_AGENT,
            'Referer': 'https://tikmate.app/',
            'Origin': 'https://tikmate.app'
        }
        
        data = {
            'url': url
        }
        
        # First request to get the download token
        response = requests.post(
            TIKTOK_API_ENDPOINTS[0], 
            headers=headers, 
            data=data
        )
        
        if response.status_code != 200:
            logger.error(f"TikMate API error: {response.status_code}")
            return False
        
        try:
            result = response.json()
            if 'token' not in result:
                logger.error("No token found in response")
                return False
            
            token = result['token']
            
            # Second request to download the actual video
            download_url = f"https://tikmate.app/download/{token}/hd.mp4"
            
            video_response = requests.get(
                download_url, 
                headers=headers, 
                stream=True
            )
            
            if video_response.status_code != 200:
                logger.error(f"Video download error: {video_response.status_code}")
                return False
            
            # Save the video file
            with open(output_path, 'wb') as f:
                for chunk in video_response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
            
            return os.path.exists(output_path) and os.path.getsize(output_path) > 0
            
        except json.JSONDecodeError:
            logger.error("Failed to parse JSON response")
            return False
            
    except Exception as e:
        logger.error(f"TikMate download error: {e}")
        return False

def download_using_snaptik(url, output_path):
    """Download TikTok video using SnapTik API"""
    try:
        headers = {
            'User-Agent': USER_AGENT,
            'Referer': 'https://snaptik.app/',
            'Origin': 'https://snaptik.app'
        }
        
        data = {
            'url': url,
            'action': 'post'
        }
        
        # First request to get the download link
        response = requests.post(
            TIKTOK_API_ENDPOINTS[2],
            headers=headers,
            data=data
        )
        
        if response.status_code != 200:
            logger.error(f"SnapTik API error: {response.status_code}")
            return False
        
        try:
            result = response.json()
            if not result.get('status') or 'data' not in result:
                logger.error("No valid data found in response")
                return False
            
            download_data = result['data']
            # Find HD download link
            download_url = None
            for item in download_data:
                if item.get('type') == 'HD':
                    download_url = item.get('url')
                    break
            
            if not download_url:
                # Fallback to first available link
                for item in download_data:
                    if 'url' in item:
                        download_url = item.get('url')
                        break
            
            if not download_url:
                logger.error("No download URL found")
                return False
            
            # Download the video
            video_response = requests.get(
                download_url,
                headers=headers,
                stream=True
            )
            
            if video_response.status_code != 200:
                logger.error(f"Video download error: {video_response.status_code}")
                return False
            
            # Save the video file
            with open(output_path, 'wb') as f:
                for chunk in video_response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
            
            return os.path.exists(output_path) and os.path.getsize(output_path) > 0
            
        except (json.JSONDecodeError, KeyError):
            logger.error("Failed to parse JSON response")
            return False
            
    except Exception as e:
        logger.error(f"SnapTik download error: {e}")
        return False
        
def get_media_type_from_content(response):
    """ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©"""
    try:
        content_type = response.headers.get('Content-Type', '').lower()
        
        if 'image' in content_type:
            return 'image'
        elif 'audio' in content_type:
            return 'audio'
        elif 'video' in content_type:
            return 'video'
        else:
            # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ÙˆØ¹ Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ù„Ù…Ù„Ù Ù…Ù† Ø¹Ù†ÙˆØ§Ù† URL
            file_ext = os.path.splitext(response.url)[-1].lower()
            if file_ext in ['.jpg', '.jpeg', '.png', '.webp', '.gif']:
                return 'image'
            elif file_ext in ['.mp3', '.wav', '.m4a', '.ogg']:
                return 'audio'
            else:
                return 'video'  # Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ ÙÙŠØ¯ÙŠÙˆ
    except:
        return 'video'  # ÙÙŠ Ø­Ø§Ù„Ø© Ø­Ø¯ÙˆØ« Ø®Ø·Ø£ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ ÙÙŠØ¯ÙŠÙˆ Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§

def get_appropriate_file_extension(media_type, url=''):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„ÙˆØ³Ø§Ø¦Ø·"""
    if media_type == 'image':
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯ Ù…Ù† URL Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ù‹Ø§
        if url and '.' in url:
            ext = os.path.splitext(url)[-1].lower()
            if ext in ['.jpg', '.jpeg', '.png', '.webp', '.gif']:
                return ext
        return '.jpg'  # Ø§Ù…ØªØ¯Ø§Ø¯ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„ØµÙˆØ±
    elif media_type == 'audio':
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯ Ù…Ù† URL Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ù‹Ø§
        if url and '.' in url:
            ext = os.path.splitext(url)[-1].lower()
            if ext in ['.mp3', '.m4a', '.wav', '.ogg']:
                return ext
        return '.mp3'  # Ø§Ù…ØªØ¯Ø§Ø¯ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„ØµÙˆØªÙŠØ§Øª
    else:  # video
        return '.mp4'  # Ø§Ù…ØªØ¯Ø§Ø¯ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª

def download_tiktok_content(url):
    """ØªÙ†Ø²ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ ØªÙŠÙƒ ØªÙˆÙƒ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©"""
    try:
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø³Ù… Ù…Ù„Ù ÙØ±ÙŠØ¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ UUID
        file_id = str(uuid.uuid4())
        video_path = TEMP_DIR / f"{file_id}.mp4"
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ†Ø²ÙŠÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… TikMate
        tikmate_success = download_using_tikmate(url, video_path)
        if tikmate_success:
            logger.info("Download successful using TikMate API")
            return video_path
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ†Ø²ÙŠÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… SnapTik
        snaptik_success = download_using_snaptik(url, video_path)
        if snaptik_success:
            logger.info("Download successful using SnapTik API")
            return video_path
        
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… RapidAPI ÙƒØ®ÙŠØ§Ø± Ø£Ø®ÙŠØ±
        try:
            video_id = extract_tiktok_id(url)
            if not video_id:
                logger.error("Failed to extract video ID")
                return None
                
            headers = {
                "X-RapidAPI-Key": RAPIDAPI_KEY,
                "X-RapidAPI-Host": RAPIDAPI_HOST
            }
            
            query = {
                "tiktok_urls": [url]
            }
            
            response = requests.post(RAPIDAPI_URL, json=query, headers=headers)
            
            if response.status_code != 200:
                logger.error(f"RapidAPI error: {response.status_code}")
                return None
                
            data = response.json()
            posts = data.get('collection', {}).get('posts', [])
            
            if not posts:
                logger.error("No posts found in response")
                return None
                
            post = posts[0]
            download_url = None
            output_path = None
            
            # Get video or image URL
            if 'images' in post and post['images']:
                # This is an image post
                download_url = post['images'][0]
                media_type = 'image'
                file_ext = get_appropriate_file_extension(media_type, download_url)
                output_path = TEMP_DIR / f"{file_id}{file_ext}"
            elif 'video' in post and post['video'] and 'download_url' in post['video']:
                # This is a video post
                download_url = post['video']['download_url']
                media_type = 'video'
                file_ext = get_appropriate_file_extension(media_type, download_url)
                output_path = TEMP_DIR / f"{file_id}{file_ext}"
            
            if not download_url or not output_path:
                logger.error("No download URL found in the response")
                return None
                
            # Download the content
            content_response = requests.get(download_url, stream=True)
            
            if content_response.status_code != 200:
                logger.error(f"Content download error: {content_response.status_code}")
                return None
                
            # Save the file
            with open(output_path, 'wb') as f:
                for chunk in content_response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
                        
            if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                logger.info(f"Download successful using RapidAPI")
                return output_path
                
        except Exception as e:
            logger.error(f"RapidAPI download error: {e}")
            
        logger.error("All download methods failed")
        return None
        
    except Exception as e:
        logger.error(f"Download error: {e}")
        return None

def convert_video_to_audio(video_path):
    """ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ Ù…Ù„Ù ØµÙˆØªÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ffmpeg"""
    try:
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø³Ù… Ù…Ù„Ù Ù„Ù„ØµÙˆØª
        audio_path = str(video_path).replace('.mp4', '.mp3')
        
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… subprocess Ù„ØªØ´ØºÙŠÙ„ ffmpeg
        subprocess.run([
            'ffmpeg', '-i', str(video_path), 
            '-q:a', '0', '-map', 'a', str(audio_path), 
            '-y'  # Ø§Ù„ÙƒØªØ§Ø¨Ø© ÙÙˆÙ‚ Ø§Ù„Ù…Ù„Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
        ], check=True, capture_output=True)
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡
        if os.path.exists(audio_path) and os.path.getsize(audio_path) > 0:
            return audio_path
        return None
    except Exception as e:
        logger.error(f"Error converting video to audio: {e}")
        return None

def clean_old_files():
    """Ø­Ø°Ù Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£ÙƒØ«Ø± Ù…Ù† Ø³Ø§Ø¹Ø©)"""
    try:
        now = datetime.now()
        threshold = now - timedelta(hours=1)
        count = 0
        
        for file_path in TEMP_DIR.glob("*"):
            try:
                # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙˆÙ‚Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ (unix timestamp)
                mtime = file_path.stat().st_mtime
                mtime_datetime = datetime.fromtimestamp(mtime)
                
                # Ø­Ø°Ù Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
                if mtime_datetime < threshold:
                    os.remove(file_path)
                    count += 1
            except Exception as e:
                logger.error(f"Error cleaning file {file_path}: {e}")
                
        logger.info(f"Cleaned {count} old files from temp directory")
    except Exception as e:
        logger.error(f"Error in clean_old_files: {e}")

def is_channel_member(user_id, channel_username):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø¶ÙˆÙ‹Ø§ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©"""
    try:
        member = bot.get_chat_member(f"@{channel_username}", user_id)
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø¶ÙˆÙŠØ© (Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©: Ø¹Ø¶ÙˆØŒ Ù…Ø´Ø±ÙØŒ Ù…Ù†Ø´Ø¦)
        if member.status in ['member', 'administrator', 'creator']:
            return True
        return False
    except Exception as e:
        logger.error(f"Error checking channel membership: {e}")
        # ÙÙŠ Ø­Ø§Ù„Ø© Ø­Ø¯ÙˆØ« Ø®Ø·Ø£ØŒ Ù†ÙØªØ±Ø¶ Ø£Ù†Ù‡ ØºÙŠØ± Ù…Ø´ØªØ±Ùƒ
        return False

def check_subscription(user_id):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ ØºÙŠØ± Ù…ÙØ¹Ù„ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ Ù…Ø´ØªØ±ÙƒÙ‹Ø§
    if not FORCE_SUBSCRIBE:
        return True
        
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ Ù…Ø·ÙˆØ± Ø§Ù„Ø¨ÙˆØªØŒ Ù„Ø§ Ù†Ø­ØªØ§Ø¬ Ù„Ù„ØªØ­Ù‚Ù‚
    if user_id == BOT_OWNER_ID:
        return True
        
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
    return is_channel_member(user_id, CHANNEL_USERNAME)

# ==========================
# === Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ===
# ==========================

@bot.message_handler(commands=['start'])
def start(message):
    """Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©ØŒ ØªØ±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ±Ù‹Ø§
    if user_id in banned_users:
        bot.send_message(chat_id, "â›” Ø£Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.")
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
    if not check_subscription(user_id):
        channels_text = f"@{CHANNEL_USERNAME}"
        msg = NOT_SUBSCRIBED_MESSAGE.format(channels=channels_text)
        bot.send_message(chat_id, msg, reply_markup=get_verify_keyboard())
        return
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨
    welcome_msg = WELCOME_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
    bot.send_message(chat_id, welcome_msg, reply_markup=get_main_keyboard())

@bot.message_handler(commands=['help'])
def help_command(message):
    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¹Ù†Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø± /help"""
    chat_id = message.chat.id
    bot.send_message(chat_id, HELP_MESSAGE, reply_markup=get_main_keyboard())

@bot.message_handler(commands=['about'])
def about_developer(message):
    """Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ù…Ø·ÙˆØ± Ø§Ù„Ø¨ÙˆØª"""
    chat_id = message.chat.id
    about_text = f"""
ğŸ“± <b>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ù…Ø·ÙˆØ±:</b>

ğŸ‘¤ <b>Ø§Ù„Ù…Ø·ÙˆØ±:</b> @{BOT_OWNER_USERNAME}

ğŸ”¹ <b>Ù„Ù„ØªÙˆØ§ØµÙ„ Ø£Ùˆ Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±:</b>
ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ± Ù…Ø¨Ø§Ø´Ø±Ø© Ø¹Ø¨Ø± Ø­Ø³Ø§Ø¨Ù‡ Ø¹Ù„Ù‰ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
    """
    bot.send_message(chat_id, about_text)

@bot.callback_query_handler(func=lambda call: call.data == "verify_subscription")
def verify_subscription(call):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    chat_id = call.message.chat.id
    user_id = call.from_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
    if check_subscription(user_id):
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø´ØªØ±ÙƒÙ‹Ø§ØŒ Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨
        bot.answer_callback_query(call.id, "âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø¨Ù†Ø¬Ø§Ø­!")
        bot.delete_message(chat_id, call.message.message_id)
        welcome_msg = WELCOME_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
        bot.send_message(chat_id, welcome_msg, reply_markup=get_main_keyboard())
    else:
        # Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…Ø´ØªØ±ÙƒÙ‹Ø§ Ø¨Ø¹Ø¯
        bot.answer_callback_query(call.id, "âŒ ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹!", show_alert=True)

@bot.message_handler(func=lambda message: bool(re.search(r'(vm\.tiktok\.com|vt\.tiktok\.com|tiktok\.com)', message.text)))
def handle_urls(message):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙˆØ§Ø¨Ø· TikTok ÙˆÙ…Ø­Ø§ÙˆÙ„Ø© ØªÙ†Ø²ÙŠÙ„Ù‡Ø§"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    tiktok_url = message.text.strip()

    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ±Ù‹Ø§
    if user_id in banned_users:
        bot.send_message(chat_id, "â›” Ø£Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.")
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
    if not check_subscription(user_id):
        channels_text = f"@{CHANNEL_USERNAME}"
        msg = NOT_SUBSCRIBED_MESSAGE.format(channels=channels_text)
        bot.send_message(chat_id, msg, reply_markup=get_verify_keyboard())
        return
    
    # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    loading_msg = bot.send_message(chat_id, LOADING_MESSAGE, parse_mode='Markdown')
    
    try:
        # ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰
        downloaded_file = download_tiktok_content(tiktok_url)
        
        if not downloaded_file:
            # ÙØ´Ù„ Ø§Ù„ØªÙ†Ø²ÙŠÙ„
            bot.edit_message_text(ERROR_MESSAGE, chat_id, loading_msg.message_id, parse_mode='Markdown')
            return
            
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
        file_size = os.path.getsize(downloaded_file)
        if file_size > MAX_FILE_SIZE:
            bot.edit_message_text(FILE_TOO_LARGE_MESSAGE, chat_id, loading_msg.message_id, parse_mode='Markdown')
            return
            
        # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡
        file_ext = os.path.splitext(downloaded_file)[1].lower()
        
        success_msg = SUCCESS_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
        
        if file_ext in ['.jpg', '.jpeg', '.png', '.webp', '.gif']:
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©
            with open(downloaded_file, 'rb') as photo:
                bot.send_photo(chat_id, photo, caption=success_msg)
        elif file_ext in ['.mp3', '.m4a', '.wav', '.ogg']:
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª
            with open(downloaded_file, 'rb') as audio:
                bot.send_audio(chat_id, audio, caption=success_msg)
        else:
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
            with open(downloaded_file, 'rb') as video:
                sent_msg = bot.send_video(chat_id, video, caption=success_msg, reply_markup=get_media_keyboard())
                # ØªØ®Ø²ÙŠÙ† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ù„Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ØµÙˆØª Ù„Ø§Ø­Ù‚Ù‹Ø§)
                user_last_video[user_id] = str(downloaded_file)
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        download_stats[user_id] += 1
        
        # Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
        bot.delete_message(chat_id, loading_msg.message_id)
        
    except Exception as e:
        logger.error(f"Error handling TikTok URL: {e}")
        bot.edit_message_text(ERROR_MESSAGE, chat_id, loading_msg.message_id, parse_mode='Markdown')

@bot.callback_query_handler(func=lambda call: call.data == "convert_to_audio")
def convert_to_audio_callback(call):
    """ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ Ù…Ù„Ù ØµÙˆØªÙŠ"""
    chat_id = call.message.chat.id
    user_id = call.from_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ÙÙŠØ¯ÙŠÙˆ Ù…Ø®Ø²Ù† Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
    if user_id not in user_last_video:
        bot.answer_callback_query(call.id, "âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙÙŠØ¯ÙŠÙˆ Ù„ØªØ­ÙˆÙŠÙ„Ù‡!", show_alert=True)
        return
        
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø± Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
    video_path = user_last_video[user_id]
    if not os.path.exists(video_path):
        bot.answer_callback_query(call.id, "âš ï¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØºÙŠØ± Ù…ØªÙˆÙØ± Ø§Ù„Ø¢Ù†. Ø­Ø§ÙˆÙ„ ØªÙ†Ø²ÙŠÙ„Ù‡ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰!", show_alert=True)
        return
        
    # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„
    bot.answer_callback_query(call.id, "ğŸµ Ø¬Ø§Ø±ÙŠ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ ØµÙˆØª...")
    converting_msg = bot.send_message(chat_id, CONVERTING_MESSAGE, parse_mode='Markdown')
    
    try:
        # ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ ØµÙˆØª
        audio_path = convert_video_to_audio(video_path)
        
        if not audio_path:
            # ÙØ´Ù„ Ø§Ù„ØªØ­ÙˆÙŠÙ„
            bot.edit_message_text(ERROR_MESSAGE, chat_id, converting_msg.message_id, parse_mode='Markdown')
            return
            
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ
        with open(audio_path, 'rb') as audio:
            success_msg = AUDIO_SUCCESS_MESSAGE.format(bot_owner=BOT_OWNER_USERNAME)
            bot.send_audio(chat_id, audio, caption=success_msg)
            
        # Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„
        bot.delete_message(chat_id, converting_msg.message_id)
        
    except Exception as e:
        logger.error(f"Error converting to audio: {e}")
        bot.edit_message_text(ERROR_MESSAGE, chat_id, converting_msg.message_id, parse_mode='Markdown')

@bot.message_handler(commands=['stats'])
def show_bot_stats(message):
    """Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù…Ø·ÙˆØ±"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # ÙÙ‚Ø· Ø§Ù„Ù…Ø·ÙˆØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ ÙÙ‚Ø· Ù„Ù„Ù…Ø·ÙˆØ±!")
        return
    
    # Ø¬Ù…Ø¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    total_users = len(download_stats)
    total_downloads = sum(download_stats.values())
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙƒØ«Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø§Ø·Ù‹Ø§
    top_users = sorted(download_stats.items(), key=lambda x: x[1], reverse=True)[:5]
    top_users_text = ""
    
    for i, (user_id, count) in enumerate(top_users, 1):
        try:
            user = bot.get_chat(user_id)
            username = f"@{user.username}" if user.username else f"User {user_id}"
            top_users_text += f"{i}. {username}: {count} Ø¹Ù…Ù„ÙŠØ© ØªÙ†Ø²ÙŠÙ„\n"
        except:
            top_users_text += f"{i}. User {user_id}: {count} Ø¹Ù…Ù„ÙŠØ© ØªÙ†Ø²ÙŠÙ„\n"
    
    # Ø¥Ø¹Ø¯Ø§Ø¯ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    stats_message = f"""
ğŸ“Š <b>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª:</b>

ğŸ‘¥ <b>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:</b> {total_users}
ğŸ“¥ <b>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙ†Ø²ÙŠÙ„Ø§Øª:</b> {total_downloads}
ğŸ”’ <b>Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†:</b> {len(banned_users)}

ğŸ” <b>Ø£ÙƒØ«Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø§Ø·Ù‹Ø§:</b>
{top_users_text}
    """
    
    bot.send_message(chat_id, stats_message)

@bot.message_handler(commands=['users'])
def show_users_count(message):
    """Ø¹Ø±Ø¶ Ø¹Ø¯Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù…Ø·ÙˆØ±"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # ÙÙ‚Ø· Ø§Ù„Ù…Ø·ÙˆØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ ÙÙ‚Ø· Ù„Ù„Ù…Ø·ÙˆØ±!")
        return
    
    # Ø¬Ù…Ø¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    total_users = len(download_stats)
    total_downloads = sum(download_stats.values())
    
    # Ø¥Ø¹Ø¯Ø§Ø¯ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    stats_message = f"""
ğŸ‘¥ <b>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:</b>

ğŸ“Š <b>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:</b> {total_users}
ğŸ“¥ <b>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙ†Ø²ÙŠÙ„Ø§Øª:</b> {total_downloads}
    """
    
    bot.send_message(chat_id, stats_message)

@bot.message_handler(commands=['ban'])
def ban_user_command(message):
    """Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # ÙÙ‚Ø· Ø§Ù„Ù…Ø·ÙˆØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ ÙÙ‚Ø· Ù„Ù„Ù…Ø·ÙˆØ±!")
        return
    
    # Ø§Ù„Ø·Ù„Ø¨ Ù…Ù† Ø§Ù„Ù…Ø·ÙˆØ± Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    bot.send_message(chat_id, "ğŸ›‘ Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø¸Ø±Ù‡ (Ø±Ù‚Ù…):")
    # ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø·ÙˆØ± Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    user_states[user_id] = "waiting_for_user_id_ban"

@bot.message_handler(commands=['unban'])
def unban_user_command(message):
    """Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # ÙÙ‚Ø· Ø§Ù„Ù…Ø·ÙˆØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    if user_id != BOT_OWNER_ID:
        bot.send_message(chat_id, "â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ ÙÙ‚Ø· Ù„Ù„Ù…Ø·ÙˆØ±!")
        return
    
    # Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
    if not banned_users:
        bot.send_message(chat_id, "â„¹ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ø­Ø§Ù„ÙŠÙ‹Ø§.")
        return
    
    # Ø¥Ø¸Ù‡Ø§Ø± Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
    banned_list = "\n".join([f"- {user_id}" for user_id in banned_users])
    bot.send_message(chat_id, f"ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†:\n{banned_list}")
    
    # Ø§Ù„Ø·Ù„Ø¨ Ù…Ù† Ø§Ù„Ù…Ø·ÙˆØ± Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    bot.send_message(chat_id, "ğŸ”“ Ø£Ø¯Ø®Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø±Ù‡ (Ø±Ù‚Ù…):")
    # ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø·ÙˆØ± Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    user_states[user_id] = "waiting_for_user_id_unban"

@bot.message_handler(func=lambda message: message.text == 'ğŸ“¥ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…')
def handle_help(message):
    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
    chat_id = message.chat.id
    bot.send_message(chat_id, HELP_MESSAGE)

@bot.message_handler(func=lambda message: message.text == 'ğŸ“Œ Ø§Ù„Ù…Ø·ÙˆØ±')
def handle_about_developer(message):
    """Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ù…Ø·ÙˆØ±"""
    chat_id = message.chat.id
    about_developer(message)

@bot.message_handler(func=lambda message: message.text == 'ğŸ“¢ Ù‚Ù†Ø§ØªÙ†Ø§')
def handle_our_channel(message):
    """Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ù‚Ù†Ø§Ø© Ø§Ù„Ø¨ÙˆØª"""
    chat_id = message.chat.id
    channel_text = f"""
ğŸ“¢ <b>Ù‚Ù†Ø§Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø³Ù…ÙŠØ©:</b>

ØªØ§Ø¨Ø¹ Ù‚Ù†Ø§ØªÙ†Ø§ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰:
- Ø¢Ø®Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
- Ø£Ø®Ø¨Ø§Ø± Ø§Ù„Ø¨ÙˆØª
- Ù…ÙŠØ²Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù‚Ø§Ø¯Ù…Ø©
- ÙˆØ¯Ø¹Ù… Ø§Ù„Ø¨ÙˆØª!

ğŸ‘‰ @{CHANNEL_USERNAME}
    """
    # Ø¥Ù†Ø´Ø§Ø¡ Ø²Ø± Ù„Ù„Ù‚Ù†Ø§Ø©
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("ğŸŒŸ Ø²ÙŠØ§Ø±Ø© Ø§Ù„Ù‚Ù†Ø§Ø©", url=f"https://t.me/{CHANNEL_USERNAME}"))
    
    bot.send_message(chat_id, channel_text, reply_markup=keyboard)

@bot.message_handler(func=lambda message: message.text == 'ğŸ“± Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø¨ÙˆØª')
def handle_share_bot(message):
    """Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†"""
    chat_id = message.chat.id
    
    share_text = f"""
ğŸ“± <b>Ø´Ø§Ø±Ùƒ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ø£ØµØ¯Ù‚Ø§Ø¦Ùƒ!</b>

Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø¨ÙˆØª ØªÙ†Ø²ÙŠÙ„ TikTok Ù…Ø¹ Ø£ØµØ¯Ù‚Ø§Ø¦Ùƒ:

https://t.me/{bot.get_me().username}

Ø´ÙƒØ±Ø§Ù‹ Ù„Ø¯Ø¹Ù…Ùƒ! ğŸ™
    """
    bot.send_message(chat_id, share_text)

@bot.message_handler(func=lambda message: message.from_user.id in user_states)
def handle_admin_action(message):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø·ÙˆØ± Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©"""
    chat_id = message.chat.id
    user_id = message.from_user.id
    
    # ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø±Ø³Ù„ Ù‡Ùˆ Ø§Ù„Ù…Ø·ÙˆØ±
    if user_id != BOT_OWNER_ID:
        return
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø·ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    state = user_states.get(user_id)
    
    if state == "waiting_for_user_id_ban":
        try:
            # Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø¹Ø±Ù Ø¥Ù„Ù‰ Ø±Ù‚Ù…
            target_user_id = int(message.text.strip())
            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
            banned_users.add(target_user_id)
            bot.send_message(chat_id, f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù…Ø¹Ø±Ù: {target_user_id}")
        except ValueError:
            bot.send_message(chat_id, "âŒ Ù…Ø¹Ø±Ù ØºÙŠØ± ØµØ§Ù„Ø­! Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­.")
        # Ø¥Ø²Ø§Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        user_states.pop(user_id, None)
    
    elif state == "waiting_for_user_id_unban":
        try:
            # Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø¹Ø±Ù Ø¥Ù„Ù‰ Ø±Ù‚Ù…
            target_user_id = int(message.text.strip())
            # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
            if target_user_id in banned_users:
                banned_users.remove(target_user_id)
                bot.send_message(chat_id, f"âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù…Ø¹Ø±Ù: {target_user_id}")
            else:
                bot.send_message(chat_id, f"â„¹ï¸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù…Ø¹Ø±Ù {target_user_id} ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±!")
        except ValueError:
            bot.send_message(chat_id, "âŒ Ù…Ø¹Ø±Ù ØºÙŠØ± ØµØ§Ù„Ø­! Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­.")
        # Ø¥Ø²Ø§Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        user_states.pop(user_id, None)

@bot.message_handler(func=lambda message: True)
def handle_text(message):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©"""
    chat_id = message.chat.id
    text = message.text.strip()
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø±ÙˆØ§Ø¨Ø· TikTok ÙÙŠ Ø§Ù„Ù†Øµ
    if re.search(r'(vm\.tiktok\.com|vt\.tiktok\.com|tiktok\.com)', text):
        # Ø¥Ø°Ø§ ÙˆØ¬Ø¯ Ø±Ø§Ø¨Ø·ØŒ Ù†Ù‚ÙˆÙ… Ø¨Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡
        handle_urls(message)
    else:
        # Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø±Ø§Ø¨Ø· TikTok ØµØ§Ù„Ø­
        bot.send_message(
            chat_id, 
            "ğŸ”¹ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ TikTok Ù„ØªØ­Ù…ÙŠÙ„Ù‡.\n\nğŸ”¸ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ 'ğŸ“¥ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…' Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯."
        )

# ==========================
# === Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ===
# ==========================

def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
    print("ğŸš€ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª TikTok Telegram Bot...")
    print("Ø§Ù„Ø¨ÙˆØª ÙŠÙ‚Ø¨Ù„ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ TikTok")
    
    # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„
    clean_old_files()
    
    # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© ÙƒÙ„ Ø³Ø§Ø¹Ø©
    import threading
    import time
    
    def clean_task():
        while True:
            time.sleep(3600)  # Ø§Ù†ØªØ¸Ø± Ø³Ø§Ø¹Ø©
            clean_old_files()
    
    # Ø¨Ø¯Ø¡ Ù…Ù‡Ù…Ø© Ø§Ù„ØªÙ†Ø¸ÙŠÙ ÙÙŠ Ø®Ù„ÙÙŠØ©
    cleaning_thread = threading.Thread(target=clean_task)
    cleaning_thread.daemon = True
    cleaning_thread.start()
    
    # Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
    try:
        bot.polling(none_stop=True, interval=0)
    except Exception as e:
        logger.error(f"Polling error: {e}")
        
if __name__ == "__main__":
    main()